<!DOCTYPE html>
<html lang="en" class="scroll-smooth bg-gradient-to-br from-indigo-900 via-indigo-800 to-indigo-900 text-indigo-100">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DSA Project</title>
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    .btn-primary { @apply bg-indigo-600 text-white px-5 py-2 rounded-md shadow-md hover:bg-indigo-700 transition; }
    .btn-secondary { @apply bg-indigo-300 text-indigo-900 px-5 py-2 rounded-md shadow-md hover:bg-indigo-400 transition; }
    .btn-accent { @apply bg-pink-600 text-white px-5 py-2 rounded-md shadow-md hover:bg-pink-700 transition; }
    .tab-btn { @apply px-5 py-2 rounded-md bg-indigo-700 hover:bg-indigo-600 text-indigo-300 font-semibold transition; }
    .tab-btn.active { @apply bg-indigo-500 text-white shadow-lg; }

    pre::-webkit-scrollbar { height: 8px; width: 8px; }
    pre::-webkit-scrollbar-thumb { background-color: #7c3aed; border-radius: 4px; }
    pre { max-height: 280px; overflow-x: auto; }

    details summary {
      cursor: pointer;
      @apply text-indigo-300 font-semibold;
    }

    .tree-node { @apply inline-block bg-indigo-600 text-white px-4 py-2 rounded-md shadow cursor-default select-none transition-colors; }
    .tree-node.highlight { @apply bg-yellow-400 text-black; }
    .tree-branch { height: 2px; background-color: #7c3aed; margin: 0 auto 1rem; width: 50px; }
  </style>
</head>

<body class="min-h-screen flex flex-col">

<header class="bg-indigo-800 shadow-md p-6 select-none">
  <div class="container mx-auto flex justify-between items-center flex-wrap gap-4">
    <h1 class="text-3xl font-bold tracking-wide">DSA Group Project</h1>
  </div>
</header>

<nav class="bg-indigo-700 shadow-inner">
  <div class="container mx-auto px-4 py-3 flex flex-wrap gap-2 justify-center select-none">
    <button class="tab-btn active" data-tab="array">Array</button>
    <button class="tab-btn" data-tab="stack">Stack</button>
    <button class="tab-btn" data-tab="queue">Queue</button>
    <button class="tab-btn" data-tab="tree">Tree Traversal</button>
    <button class="tab-btn" data-tab="code">Code Implementations</button>
    <button class="tab-btn" data-tab="algorithms">Algorithms</button>
    <button class="tab-btn" data-tab="pseudocode">Pseudocode</button>
  </div>
</nav>

<main class="flex-grow container mx-auto px-6 py-8 max-w-7xl">

<!-- ==================================== -->
<!--             ARRAY SECTION            -->
<!-- ==================================== -->
<section id="array" class="tab-content space-y-4">
  <h2 class="text-3xl font-extrabold mb-4 text-indigo-300">Array Visualizer</h2>

  <div class="flex flex-col md:flex-row gap-4">
    <input type="text" id="array-input" placeholder="Enter value"
      class="flex-grow p-3 rounded-md text-indigo-900 focus:outline-none focus:ring-2 focus:ring-indigo-400" />
    <div class="flex gap-3 flex-wrap">
      <button id="array-add-btn" class="btn-primary">Add</button>
      <button id="array-remove-btn" class="btn-secondary">Remove</button>
      <button id="array-search-btn" class="btn-accent">Search</button>
      <button id="array-clear-btn" class="btn-accent">Clear</button>
    </div>
  </div>

  <p id="array-message" class="min-h-[1.5rem] text-indigo-300 font-semibold"></p>
  <div id="array-container" class="flex flex-wrap gap-3"></div>
</section>

<!-- ==================================== -->
<!--               STACK SECTION          -->
<!-- ==================================== -->
<section id="stack" class="tab-content hidden space-y-4">
  <h2 class="text-3xl font-extrabold mb-4 text-indigo-300">Stack Visualizer</h2>

  <div class="flex flex-col md:flex-row gap-4">
    <input type="text" id="stack-input" placeholder="Enter value"
      class="flex-grow p-3 rounded-md text-indigo-900 focus:outline-none focus:ring-2 focus:ring-indigo-400" />

    <div class="flex gap-3 flex-wrap">
      <button id="stack-push-btn" class="btn-primary">Push</button>
      <button id="stack-pop-btn" class="btn-secondary">Pop</button>
      <button id="stack-peek-btn" class="btn-accent">Peek</button>
      <button id="stack-clear-btn" class="btn-accent">Clear</button>
    </div>
  </div>

  <p id="stack-message" class="min-h-[1.5rem] text-indigo-300 font-semibold"></p>
  <div id="stack-container" class="flex flex-col-reverse gap-2"></div>
</section>

<!-- ==================================== -->
<!--               QUEUE SECTION          -->
<!-- ==================================== -->
<section id="queue" class="tab-content hidden space-y-4">
  <h2 class="text-3xl font-extrabold mb-4 text-indigo-300">Queue Visualizer</h2>

  <div class="flex flex-col md:flex-row gap-4">
    <input type="text" id="queue-input" placeholder="Enter value"
      class="flex-grow p-3 rounded-md text-indigo-900 focus:outline-none focus:ring-2 focus:ring-indigo-400" />

    <div class="flex gap-3 flex-wrap">
      <button id="queue-enqueue-btn" class="btn-primary">Enqueue</button>
      <button id="queue-dequeue-btn" class="btn-secondary">Dequeue</button>
      <button id="queue-peek-btn" class="btn-accent">Peek</button>
      <button id="queue-clear-btn" class="btn-accent">Clear</button>
    </div>
  </div>

  <p id="queue-message" class="min-h-[1.5rem] text-indigo-300 font-semibold"></p>
  <div id="queue-container" class="flex gap-4 flex-wrap"></div>
</section>

<!-- ==================================== -->
<!--         TREE TRAVERSAL SECTION       -->
<!-- ==================================== -->
<section id="tree" class="tab-content hidden space-y-6">
  <h2 class="text-3xl font-extrabold text-indigo-300">Binary Tree Traversal Visualizer</h2>

  <div id="tree-container" class="flex justify-center flex-wrap gap-6 bg-indigo-800 rounded-lg p-6 shadow-md">
    <div style="text-align:center; min-width: 250px;">
      <div class="tree-node" id="tree-node-1" data-id="1">1</div>
      <div class="tree-branch"></div>

      <div class="flex justify-center gap-16 mt-3">
        <div>
          <div class="tree-node" id="tree-node-2" data-id="2">2</div>
          <div class="tree-branch w-16"></div>

          <div class="flex justify-center gap-8 mt-3">
            <div><div class="tree-node" id="tree-node-4" data-id="4">4</div></div>
            <div><div class="tree-node" id="tree-node-5" data-id="5">5</div></div>
          </div>
        </div>

        <div>
          <div class="tree-node" id="tree-node-3" data-id="3">3</div>
          <div class="tree-branch w-16"></div>

          <div class="flex justify-center gap-8 mt-3">
            <div><div class="tree-node" id="tree-node-6" data-id="6">6</div></div>
            <div><div class="tree-node" id="tree-node-7" data-id="7">7</div></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="flex flex-wrap gap-3 justify-center">
    <button id="preorder-btn" class="btn-primary">Preorder</button>
    <button id="inorder-btn" class="btn-primary">Inorder</button>
    <button id="postorder-btn" class="btn-primary">Postorder</button>
    <button id="clear-tree-btn" class="btn-secondary">Clear Highlight</button>
  </div>

  <p id="tree-message" class="min-h-[1.5rem] text-indigo-300 font-semibold mt-2 text-center"></p>
</section>

<!-- ==================================== -->
<!--         CODE IMPLEMENTATIONS         -->
<!-- ==================================== -->
<section id="code" class="tab-content hidden space-y-10">
  <h2 class="text-3xl font-extrabold text-indigo-300">Code Implementations</h2>

  <details open>
    <summary>Array Implementation</summary>
    <pre class="bg-indigo-900 p-4 rounded-lg"><code>

C++ - Array Operation

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> arr;
    
    // Add elements
    arr.push_back(10);
    arr.push_back(20);
    arr.push_back(30);
    cout << "After adding: ";
    for(int x : arr) cout << x << " ";
    cout << endl;
    
    // Search element
    int search_val = 20;
    auto it = find(arr.begin(), arr.end(), search_val);
    if(it != arr.end()) {
        cout << search_val << " found at index " 
             << (it - arr.begin()) << endl;
    } else {
        cout << search_val << " not found" << endl;
    }
    
    // Remove last element
    int removed = arr.back();
    arr.pop_back();
    cout << "Removed: " << removed << endl;
    cout << "After removing: ";
    for(int x : arr) cout << x << " ";
    cout << endl;
    
    // Access element
    cout << "First element: " << arr[0] << endl;
    cout << "Array size: " << arr.size() << endl;
    
    return 0;
}

/* Output:
After adding: 10 20 30 
20 found at index 1
Removed: 30
After removing: 10 20 
First element: 10
Array size: 2
*/

Python - Array Operation

arr = []

arr.append(10)
arr.append(20)
arr.append(30)
print("After adding:", arr)

search_val = 20
if search_val in arr:
    index = arr.index(search_val)
    print(f"{search_val} found at index {index}")
else:
    print(f"{search_val} not found")

removed = arr.pop()
print(f"Removed: {removed}")
print("After removing:", arr)

 Access element
print("First element:", arr[0])
print("Array length:", len(arr))

Output:
After adding: [10, 20, 30]
20 found at index 1
Removed: 30
After removing: [10, 20]
First element: 10
Array length: 2
    </code></pre>
  </details>

  <details>
    <summary>Stack Implementation</summary>
    <pre class="bg-indigo-900 p-4 rounded-lg"><code>

C++ - Stack Operations & Expression Conversion

#include <iostream>
#include <stack>
#include <string>
#include <algorithm>
using namespace std;

int precedence(char op) {
    if(op == '+' || op == '-') return 1;
    if(op == '*' || op == '/') return 2;
    if(op == '^') return 3;
    return 0;
}

string infixToPostfix(string exp) {
    stack<char> st;
    string result = "";
    for(char ch : exp) {
        if(isalnum(ch)) {
            result += ch;
        }
        else if(ch == '(') {
            st.push(ch);
        }
        else if(ch == ')') {
            while(!st.empty() && st.top() != '(') {
                result += st.top();
                st.pop();
            }
            st.pop();
        }
        else {
            while(!st.empty() && precedence(st.top()) >= precedence(ch)) {
                result += st.top();
                st.pop();
            }
            st.push(ch);
        }
    }
    while(!st.empty()) {
        result += st.top();
        st.pop();
    }
    return result;
}

string infixToPrefix(string exp) {
    reverse(exp.begin(), exp.end());
    for(int i = 0; i < exp.length(); i++) {
        if(exp[i] == '(') exp[i] = ')';
        else if(exp[i] == ')') exp[i] = '(';
    }
    string postfix = infixToPostfix(exp);
    reverse(postfix.begin(), postfix.end());
    return postfix;
}

int main() {
    // Stack Push/Pop Operations
    stack<int> st;
    st.push(10);
    st.push(20);
    st.push(30);
    cout << "Stack size: " << st.size() << endl;
    cout << "Top element: " << st.top() << endl;
    
    int popped = st.top();
    st.pop();
    cout << "\nPopped: " << popped << endl;
    cout << "After pop, size: " << st.size() << endl;
    cout << "New top: " << st.top() << endl;
    
    // Expression Conversion
    string infix = "2+3*4";
    cout << "\nInfix: " << infix << endl;
    cout << "Postfix: " << infixToPostfix(infix) << endl;
    cout << "Prefix: " << infixToPrefix(infix) << endl;
    
    string infix2 = "(2+3)*4";
    cout << "\nInfix: " << infix2 << endl;
    cout << "Postfix: " << infixToPostfix(infix2) << endl;
    cout << "Prefix: " << infixToPrefix(infix2) << endl;
    
    return 0;
}

/* Output:
Stack size: 3
Top element: 30

Popped: 30
After pop, size: 2
New top: 20

Infix: 2+3*4
Postfix: 234*+
Prefix: +2*34

Infix: (2+3)*4
Postfix: 23+4*
Prefix: *+234
*/

Python - Stack Operations & Expression Conversion

stack = []

stack.append(10)
stack.append(20)
stack.append(30)
print("Stack after push:", stack)
print("Top element:", stack[-1])
print("Stack size:", len(stack))

popped = stack.pop()
print("\nPopped element:", popped)
print("Stack after pop:", stack)
print("New top:", stack[-1])

def precedence(op):
    if op in ['+', '-']: return 1
    if op in ['*', '/']: return 2
    if op == '^': return 3
    return 0

def infix_to_postfix(exp):
    stack, result = [], ""
    for ch in exp:
        if ch.isalnum():
            result += ch
        elif ch == '(':
            stack.append(ch)
        elif ch == ')':
            while stack and stack[-1] != '(':
                result += stack.pop()
            stack.pop()
        else:
            while stack and precedence(stack[-1]) >= precedence(ch):
                result += stack.pop()
            stack.append(ch)
    while stack:
        result += stack.pop()
    return result

def infix_to_prefix(exp):
    exp = exp[::-1]
    exp = exp.replace('(', 'temp').replace(')', '(').replace('temp', ')')
    postfix = infix_to_postfix(exp)
    return postfix[::-1]

infix = "2+3*4"
print(f"\nInfix: {infix}")
print(f"Postfix: {infix_to_postfix(infix)}")
print(f"Prefix: {infix_to_prefix(infix)}")

infix2 = "(2+3)*4"
print(f"\nInfix: {infix2}")
print(f"Postfix: {infix_to_postfix(infix2)}")
print(f"Prefix: {infix_to_prefix(infix2)}")

Output:
Stack after push: [10, 20, 30]
Top element: 30
Stack size: 3
 
Popped element: 30
Stack after pop: [10, 20]
New top: 20
 
Infix: 2+3*4
Postfix: 234*+
Prefix: +2*34
 
Infix: (2+3)*4
Postfix: 23+4*
Prefix: *+234
    </code></pre>
  </details>

  <details>
    <summary>Queue Implementation</summary>
    <pre class="bg-indigo-900 p-4 rounded-lg"><code>

C++ - Queue Operation

#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<int> q;
    
    // Enqueue (add to rear)
    q.push(10);
    q.push(20);
    q.push(30);
    cout << "Queue size: " << q.size() << endl;
    cout << "Front element: " << q.front() << endl;
    cout << "Rear element: " << q.back() << endl;
    
    // Dequeue (remove from front)
    cout << "\nDequeued: " << q.front() << endl;
    q.pop();
    
    cout << "After dequeue:" << endl;
    cout << "Size: " << q.size() << endl;
    cout << "Front: " << q.front() << endl;
    cout << "Rear: " << q.back() << endl;
    
    // Check if empty
    cout << "Is empty: " << (q.empty() ? "Yes" : "No") << endl;
    
    // Enqueue more
    q.push(40);
    cout << "\nAfter enqueue 40:" << endl;
    cout << "Size: " << q.size() << endl;
    cout << "Front: " << q.front() << endl;
    cout << "Rear: " << q.back() << endl;
    
    return 0;
}

/* Output:
Queue size: 3
Front element: 10
Rear element: 30

Dequeued: 10
After dequeue:
Size: 2
Front: 20
Rear: 30
Is empty: No

After enqueue 40:
Size: 3
Front: 20
Rear: 40
*/

Python - Queue Operation

queue = []

queue.append(10)
queue.append(20)
queue.append(30)
print("Queue after enqueue:", queue)
print("Front element:", queue[0])
print("Rear element:", queue[-1])
print("Queue size:", len(queue))

front = queue.pop(0)
print("\nDequeued element:", front)
print("Queue after dequeue:", queue)
print("New front:", queue[0])
print("Queue size:", len(queue))

print("Is empty:", len(queue) == 0)

from collections import deque
queue_deque = deque([10, 20, 30])
print("\n--- Using deque ---")
print("Queue:", list(queue_deque))

queue_deque.append(40)  
print("After enqueue 40:", list(queue_deque))

front = queue_deque.popleft()  # Dequeue
print("Dequeued:", front)
print("After dequeue:", list(queue_deque))

Output:
Queue after enqueue: [10, 20, 30]
Front element: 10
Rear element: 30
Queue size: 3
 
Dequeued element: 10
Queue after dequeue: [20, 30]
New front: 20
Queue size: 2
Is empty: False
 
--- Using deque ---
Queue: [10, 20, 30]
After enqueue 40: [10, 20, 30, 40]
Dequeued: 10
After dequeue: [20, 30, 40]
    </code></pre>
  </details>

  <details>
    <summary>Binary Tree Traversal Implementation</summary>
    <pre class="bg-indigo-900 p-4 rounded-lg"><code>

C++ - Binary Tree Traversal

#include <iostream>
using namespace std;

struct Node {
    int data;
    Node *left, *right;
    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

// Inorder Traversal (Left -> Root -> Right)
void inorder(Node* node) {
    if(node != nullptr) {
        inorder(node->left);
        cout << node->data << " ";
        inorder(node->right);
    }
}

// Preorder Traversal (Root -> Left -> Right)
void preorder(Node* node) {
    if(node != nullptr) {
        cout << node->data << " ";
        preorder(node->left);
        preorder(node->right);
    }
}

// Postorder Traversal (Left -> Right -> Root)
void postorder(Node* node) {
    if(node != nullptr) {
        postorder(node->left);
        postorder(node->right);
        cout << node->data << " ";
    }
}

int main() {
    // Build the tree:
    //     1
    //    / \
    //   2   3
    //  / \
    // 4   5
    
    Node* root = new Node(1);
    root->left = new Node(2);
    root->right = new Node(3);
    root->left->left = new Node(4);
    root->left->right = new Node(5);
    
    cout << "Inorder Traversal: ";
    inorder(root);
    cout << endl;
    
    cout << "Preorder Traversal: ";
    preorder(root);
    cout << endl;
    
    cout << "Postorder Traversal: ";
    postorder(root);
    cout << endl;
    
    return 0;
}

/* Output:
Inorder Traversal: 4 2 5 1 3 
Preorder Traversal: 1 2 4 5 3 
Postorder Traversal: 4 5 2 3 1 
*/

Python - Binary Tree Traversal

class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

 Build the tree:
     1
    / \
   2   3
  / \
 4   5

root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)

 Inorder Traversal (Left -> Root -> Right)
def inorder(node):
    if node:
        inorder(node.left)
        print(node.data, end=' ')
        inorder(node.right)

 Preorder Traversal (Root -> Left -> Right)
def preorder(node):
    if node:
        print(node.data, end=' ')
        preorder(node.left)
        preorder(node.right)

  Postorder Traversal (Left -> Right -> Root)
def postorder(node):
    if node:
        postorder(node.left)
        postorder(node.right)
        print(node.data, end=' ')

print("Inorder Traversal: ", end='')
inorder(root)
print()

print("Preorder Traversal: ", end='')
preorder(root)
print()

print("Postorder Traversal: ", end='')
postorder(root)
print()

Output:
Inorder Traversal: 4 2 5 1 3
Preorder Traversal: 1 2 4 5 3
Postorder Traversal: 4 5 2 3 1
    </code></pre>
  </details>
</section>

<!-- ==================================== -->
<!--            ALGORITHMS                -->
<!-- ==================================== -->
<section id="algorithms" class="tab-content hidden space-y-6">
  <h2 class="text-3xl font-extrabold text-indigo-300">Algorithms</h2>

  <div class="space-y-6">
    <h3 class="text-xl font-bold">1. Linear Search</h3>
    <p>Checks items one by one.</p>

    <h3 class="text-xl font-bold">2. Binary Search</h3>
    <p>Efficient search on sorted arrays.</p>

    <h3 class="text-xl font-bold">3. Bubble Sort</h3>
    <p>Repeatedly swaps adjacent items.</p>

    <h3 class="text-xl font-bold">4. Selection Sort</h3>
    <p>Select smallest and move to front.</p>

    <h3 class="text-xl font-bold">5. Insertion Sort</h3>
    <p>Builds sorted list one element at a time.</p>

    <h3 class="text-xl font-bold">6. Merge Sort</h3>
    <p>Divide and conquer sorting technique.</p>

    <h3 class="text-xl font-bold">7. Quick Sort</h3>
    <p>Partition-based efficient sorting.</p>

    <h3 class="text-xl font-bold">8. BFS</h3>
    <p>Level-order traversal of graphs/trees.</p>

    <h3 class="text-xl font-bold">9. DFS</h3>
    <p>Depth-first exploration.</p>

    <h3 class="text-xl font-bold">10. Dijkstra Algorithm</h3>
    <p>Shortest path in weighted graphs.</p>
  </div>
</section>

<!-- ==================================== -->
<!--             PSEUDOCODE              -->
<!-- ==================================== -->
<section id="pseudocode" class="tab-content hidden space-y-6">
  <h2 class="text-3xl font-extrabold text-indigo-300">Pseudocode</h2>

  <div class="space-y-6">

    <details>
      <summary>1. Linear Search</summary>
      <pre><code>
FOR i = 0 TO n-1
  IF arr[i] == target
    RETURN i
RETURN -1
      </code></pre>
    </details>

    <details>
      <summary>2. Binary Search</summary>
      <pre><code>
low = 0
high = n - 1
WHILE low <= high
  mid = (low + high) / 2
  IF arr[mid] == target RETURN mid
  ELSE IF target < arr[mid] high = mid - 1
  ELSE low = mid + 1
RETURN -1
      </code></pre>
    </details>

    <details>
      <summary>3. Bubble Sort</summary>
      <pre><code>
FOR i = 0 TO n-1
  FOR j = 0 TO n-i-1
    IF arr[j] > arr[j+1]
      SWAP arr[j], arr[j+1]
      </code></pre>
    </details>

    <details>
      <summary>4. Selection Sort</summary>
      <pre><code>
FOR i = 0 TO n-1
  min = i
  FOR j = i+1 TO n-1
    IF arr[j] < arr[min]
      min = j
  SWAP arr[i], arr[min]
      </code></pre>
    </details>

    <details>
      <summary>5. Insertion Sort</summary>
      <pre><code>
FOR i = 1 TO n-1
  key = arr[i]
  j = i - 1
  WHILE j >= 0 AND arr[j] > key
    arr[j+1] = arr[j]
    j--
  arr[j+1] = key
      </code></pre>
    </details>

    <details>
      <summary>6. Merge Sort</summary>
      <pre><code>
IF size <= 1 RETURN
Split array into left and right
MergeSort(left)
MergeSort(right)
Merge(left, right)
      </code></pre>
    </details>

    <details>
      <summary>7. Quick Sort</summary>
      <pre><code>
IF low < high
  pivot = Partition(arr, low, high)
  QuickSort(low, pivot - 1)
  QuickSort(pivot + 1, high)
      </code></pre>
    </details>

    <details>
      <summary>8. BFS</summary>
      <pre><code>
CREATE queue
ENQUEUE start
WHILE queue NOT EMPTY
  node = DEQUEUE
  FOR each neighbor
    IF not visited
      ENQUEUE neighbor
      </code></pre>
    </details>

    <details>
      <summary>9. DFS</summary>
      <pre><code>
DFS(node):
  mark visited
  FOR each neighbor
    IF not visited
      DFS(neighbor)
      </code></pre>
    </details>

    <details>
      <summary>10. Dijkstra's Algorithm</summary>
      <pre><code>
SET all distances = infinity
distance[start] = 0
WHILE unvisited exist
  node = smallest distance
  FOR each neighbor
    IF new distance < old
      update distance
      </code></pre>
    </details>

  </div>
</section>

</main>

<footer class="bg-indigo-800 p-4 text-center text-indigo-300 select-none">
  &copy; 2025 Website Group Project
</footer>

<!-- ==================================== -->
<!--        JAVASCRIPT FUNCTIONALITY      -->
<!-- ==================================== -->
<script>
/* TAB SWITCHING */
const tabs = document.querySelectorAll(".tab-btn");
const contents = document.querySelectorAll(".tab-content");

function activateTab(tabName) {
  contents.forEach(c => {
    c.classList.toggle("hidden", c.id !== tabName);
    c.classList.toggle("block", c.id === tabName);
  });
  tabs.forEach(t => t.classList.toggle("active", t.dataset.tab === tabName));
}

tabs.forEach(tab => tab.addEventListener("click", () => activateTab(tab.dataset.tab)));
activateTab("array");

/* ARRAY */
let arrayData = [];
const arrayInput = document.getElementById("array-input");
const arrayContainer = document.getElementById("array-container");
const arrayMessage = document.getElementById("array-message");

function renderArray() {
  arrayContainer.innerHTML = "";
  arrayData.forEach(item => {
    const el = document.createElement("div");
    el.textContent = item;
    el.className = "bg-indigo-600 rounded-md px-4 py-2 shadow-md";
    arrayContainer.appendChild(el);
  });
}

document.getElementById("array-add-btn").onclick = () => {
  let vals = arrayInput.value.split(",").map(x => x.trim()).filter(Boolean);
  if (!vals.length) return (arrayMessage.textContent = "Please enter a value.");
  arrayData.push(...vals);
  arrayInput.value = "";
  arrayMessage.textContent = `Added ${vals.length} value(s).`;
  renderArray();
};

document.getElementById("array-remove-btn").onclick = () => {
  let vals = arrayInput.value.split(",").map(x => x.trim()).filter(Boolean);
  let removed = 0;

  vals.forEach(v => {
    let index = arrayData.indexOf(v);
    if (index !== -1) {
      arrayData.splice(index, 1);
      removed++;
    }
  });

  arrayMessage.textContent = `Removed ${removed} value(s).`;
  renderArray();
};

document.getElementById("array-search-btn").onclick = () => {
  let val = arrayInput.value.trim();
  let index = arrayData.indexOf(val);
  if (index === -1) return (arrayMessage.textContent = `"${val}" not found.`);

  arrayMessage.textContent = `"${val}" found at index ${index}.`;
  renderArray();

  const child = arrayContainer.children[index];
  child.classList.add("bg-pink-500");
  setTimeout(() => child.classList.remove("bg-pink-500"), 1500);
};

/* STACK */
let stackData = [];
const stackMessage = document.getElementById("stack-message");

function renderStack() {
  const container = document.getElementById("stack-container");
  container.innerHTML = "";
  stackData.forEach(v => {
    const el = document.createElement("div");
    el.textContent = v;
    el.className = "bg-indigo-600 rounded-md px-6 py-3 shadow-md";
    container.appendChild(el);
  });
}

document.getElementById("stack-push-btn").onclick = () => {
  const val = document.getElementById("stack-input").value.trim();
  if (!val) return (stackMessage.textContent = "Enter a value.");
  if (stackData.length >= 5) return (stackMessage.textContent = "Stack full (max=5).");

  stackData.push(val);
  stackMessage.textContent = `Pushed "${val}".`;
  renderStack();
};

document.getElementById("stack-pop-btn").onclick = () => {
  if (!stackData.length) return (stackMessage.textContent = "Stack empty.");
  stackMessage.textContent = `Popped "${stackData.pop()}".`;
  renderStack();
};

document.getElementById("stack-peek-btn").onclick = () => {
  stackMessage.textContent = stackData.length ? `Top: "${stackData.at(-1)}".` : "Stack empty.";
};

document.getElementById("stack-clear-btn").onclick = () => {
  stackData = [];
  stackMessage.textContent = "Stack cleared.";
  renderStack();
};

/* QUEUE */
let queueData = [];
const queueMessage = document.getElementById("queue-message");

function renderQueue() {
  const container = document.getElementById("queue-container");
  container.innerHTML = "";
  queueData.forEach(v => {
    const el = document.createElement("div");
    el.textContent = v;
    el.className = "bg-indigo-600 rounded-md px-5 py-2 shadow-md";
    container.appendChild(el);
  });
}

document.getElementById("queue-enqueue-btn").onclick = () => {
  const val = document.getElementById("queue-input").value.trim();
  if (!val) return (queueMessage.textContent = "Enter a value.");
  queueData.push(val);
  queueMessage.textContent = `Enqueued "${val}".`;
  renderQueue();
};

document.getElementById("queue-dequeue-btn").onclick = () => {
  if (!queueData.length) return (queueMessage.textContent = "Queue empty.");
  queueMessage.textContent = `Dequeued "${queueData.shift()}".`;
  renderQueue();
};

document.getElementById("queue-peek-btn").onclick = () => {
  queueMessage.textContent = queueData.length ? `Front: "${queueData[0]}"` : "Queue empty.";
};

document.getElementById("queue-clear-btn").onclick = () => {
  queueData = [];
  queueMessage.textContent = "Queue cleared.";
  renderQueue();
};

/* TREE */
const treeNodes = {
  1:{left:2,right:3},2:{left:4,right:5},3:{left:6,right:7},
  4:{left:null,right:null},5:{left:null,right:null},
  6:{left:null,right:null},7:{left:null,right:null}
};

function clearHighlights() {
  Object.keys(treeNodes).forEach(id => {
    document.getElementById(`tree-node-${id}`).classList.remove("highlight");
  });
  document.getElementById("tree-message").textContent = "";
}

async function highlightSequence(seq) {
  clearHighlights();
  const msg = document.getElementById("tree-message");
  msg.textContent = "Traversal started...";

  for (const id of seq) {
    const el = document.getElementById(`tree-node-${id}`);
    el.classList.add("highlight");
    msg.textContent = `Visiting node ${id}`;
    await new Promise(r => setTimeout(r, 800));
    el.classList.remove("highlight");
  }

  msg.textContent = "Traversal complete.";
}

function preorder(id,res=[]) {
  if(!id) return res;
  res.push(id);
  preorder(treeNodes[id].left,res);
  preorder(treeNodes[id].right,res);
  return res;
}
function inorder(id,res=[]) {
  if(!id) return res;
  inorder(treeNodes[id].left,res);
  res.push(id);
  inorder(treeNodes[id].right,res);
  return res;
}
function postorder(id,res=[]) {
  if(!id) return res;
  postorder(treeNodes[id].left,res);
  postorder(treeNodes[id].right,res);
  res.push(id);
  return res;
}

document.getElementById("preorder-btn").onclick = () => highlightSequence(preorder(1));
document.getElementById("inorder-btn").onclick = () => highlightSequence(inorder(1));
document.getElementById("postorder-btn").onclick = () => highlightSequence(postorder(1));
document.getElementById("clear-tree-btn").onclick = clearHighlights;

</script>
</body>
</html>
